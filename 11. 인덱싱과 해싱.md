#### 11장

## 인덱싱과 해싱

- 질의는 파일 내의 레코드 중 극히 일부분만 참조

### 기본 개념

- 데이터베이스 시스템은 인덱스를 이용해 대응되는 레코드가 어느 디스크 블록에 있는지 먼저 찾음
- 인덱스의 종류
  1. 순서 인덱스 : 값에 대해 정렬된 순서
  2. 해시 인덱스 : 일정하게 분배, 해시 함수에 의해 버킷 결정
- 인덱스의 평가
  1. 엑세스 형태
  2. 엑세스 시간 : 집합을 찾는데 걸리는 시간
  3. 삽입 시간 : 새로운 데이터 항목을 삽입하는데 걸리는 시간 = 인덱스 구조를 갱신
  4. 삭제 시간 : 인덱스 구조를 갱신하는데 걸리는 시간
  5. 공간 부담 : 부가적인 공간
- 리코드를 찾는데 사용되는 속성이나 속성들의 집합 : 검색 키(search key) 

### 순서 인덱스

- 레코드에 대한 임의 접근을 빨리하기 위해서 인덱스 구조를 사용
  - 인덱스 구조는 특정한 검색 키와 관련이 있음
- 클러스터링 인덱스 : 레코드를 포함하는 파일이 연속적인 순서로 되어있는 경우
  - 주 인덱스(primary index)
  - 임의의 어떤 검색 키에 대해서도 주 인덱스를 구축할 수 있음
    - 클러스터링 읻게스에서 검색 키는 주 키인 경우가 많지만 반드시 그럴 필요는 없음
  - 주 키를 가진다고 선언되면 대부분 주 키에 대한 인덱스를 자동적으로 생성
    - 인덱스는 주 키 제약 조건이 위배되었는지 검사하는데 사용됨
- 비클러스터링 인덱스(2차 인덱스, secondary index) : 파일의 연속적인 순서와 다른 순서로 구성되는 검색 키의 인덱스

#### 밀집과 희소 인덱스

- 인덱스 레코드 : 컴색 키 값 + 포인터
  - 검색 키 값으로 가지는 한개 이상의 레코드에 대한 포인터

1. 밀집 인덱스(dense index) : 파일에 있는 모든 검색키에 대해서 인덱스 엔트리 유지

   - 똑같은 검색 키를 가진 모든 레코드에 대한 포인터 목록을 저장
   - 빠름

2. 희소 인덱스(sparse index) : 검색 키 값에 대해 인덱스 엔트리를 단지 몇개만 나타냄

   - 인덱스가 클러스터링 인덱스인 경우 사용될 수 있음

   - 더 적은 공간을 요구 = 삽입과 삭제에 대한 유지 부담이 더 적음

- 엑세스 시간과 공간 부담사이에 trade-off 존재

#### 다단계 인덱스

- 대용량의 인덱스는 디스크 상에 연속적인 파일로 저장됨
  - 전체 인덱스가 메모리에 유지될 수 없음 만큼 크다면 필요할 때마다 인덱스 블록을 디스크로부터 가져와야 함 = 여러개의 디스크 블록을 읽어야 함
  - 오버플로우 블록이 사용된다면 이진 검색을 불가능 : 일반적으로 순차 검색을 사용함
- 내부 인덱스라고 불리는 원래의 주 인덱스에 대한 희소 외부 인덱스를 구성
  - 외부 인덱스 상에서 이진 검색을 이용해서 원하는 레코드를 찾을 수 있음
    - 레코드 블록은 내부 인덱스 블록을 가리킴
- 두개 이상의 단계를 가지는 인덱스를 다단계 인덱스라고 함

#### 인덱스 갱신

- 인덱스는 어떤 레코드가 파일에 삽입되거나 파일로부터 삭제될 때마다 갱신되어야 함
  - 삽입과 삭제만 고려하고 갱신은 고려하지 않아도 됨

- 삽입(insertion) : 삽입되는 레코드의 검색 키 값을 사용해서 찾기를 수행
  - 밀집
    1. 검색 키 값이 인덱스에 없으면 적당한 위치에 엔트리를 삽입
    2. 키 값이 있다면 똑같은 검색 키 값을 가지는 다른 레코드들 위에 삽입된 레코드를 위치
  - 희소
    1. 첫 번째 검색 키 값이면 인덱스에 삽입
    2. 가장 작은 검색 키 값이라면 해당 블록을 가리키고 있는 인덱스 엔트리를 갱신
- 삭제
  - 밀집
    1. 검색 키 값을 가지는 유일한 레코드인 경우 대응되는 인덱스 엔트리를 삭제
    2. 똑같은 검색 키 값을 가지는 다음 레코드를 가리키도록 갱신, 해당 엔트리 삭제
  - 희소
    1. 인덱스가 해당 레코드의 검색 키 값을 포함하지 않는다면 아무것도 하지 않음
    2. 해당 레코드를 삭제하고 다음 레코드를 가리키도록 인덱스 생신

#### 2차 인덱스

- 모든 검색 키 값과 모든 레코드에 대한 포인터를 가지는 인덱스 엔트리
  - 반드시 밀집 인덱스
  - 중간 검색 키 값을 가지는 레코드는 파일의 어딘가에 있기 때문에 일반적으로 전체 파일을 검색하지 않고서는 찾을 수 없음
  - 연속적인 값에 의해 가리켜지는 레코드가 연속적으로 저장되어 있지는 않음
    - 2차 키 순서와 물리적은 키 순서는 다름
    - 각 레코드를 읽는 것은 디스크로부터 새로운 블록 읽기를 요구하는 것과 동일함
- 주 인덱스 검색 키가 아닌 다른 키를 사용하는 질의문의 성능을 향상
  - 데이터베이스 변경에 상당한 부담
  - 데이터 변경의 상대적인 빈도에 따하 구축

#### 다중 키 상의 인덱스

- 두 개 이상의 속성들로 구성된 검색 키를 복합 검색 키라고 함
  - 검색 키가 하나의 속성이 아니라 속성들의 목록으로 되어있음

### B+- 트리 인덱스 파일

- B+ 인덱스 구조 : 데이터의 삽입과 삭제에도 불구하고 성능을 유지할 수 있음
  - 단말 노드까지의 모든 경로의 길이가 같은 균형 트리(balanced tree)

#### B+ 트리의 구조

- 노드 안의 검색 키 값은 정렬된 순서로 유지됨
  - 포인터 P는 검색 키 값 K를 가지는 파일 레코드를 가리킴
- 각 단말 노드는 n-1개까지 값을 가질 수 있음
  - 단말 노드는 적어도 (n-1)/2 개의 값을 포함해야 함
- 비단말 노드는 단말 도느 상에서 다단계 희소 인덱스를 형성함
  - P는 Ki 보다는 작고, Ki-1 보다는 크거가 같은 검색 키를 포함하는 하위트리를 가리킴
  - 비단말 노드는 n개 까지의 포인터를 가질 수 있음
  - 적어도 n/2 개의 포인터를 가지고 있어야 함

- fanout : 한 노드의 포인터 수

#### B+ 트리 상에서의 질의

- 트리의 루트에서부터 시작해서 트리 안에 존재하는 특정 값을 포함하는 단말 노드에 도달할 때까지 아래 방향으로 탐색
  - V값보다 큰 검색 키 K를 만족시키는 가장 작은 i 값을 찾음

- 범위 질의 : 특정 범위의 검색 키를 가지는 모든 레코드를 찾음

#### B+ 트리 상에서의 갱신

- 삽입 결과로 노드가 너무 커버리면 분할 하거나 노드가 너무 작아져서 노드를 결합해야 하는 경우
- 삽입
  - 삽입할 공간이 업으면 한 노드는 두 노르로 분할됨
  - 부모 노드에 공간이 없으면 부모 노드는 부모 노드에 추가될 엔트리를 요구하면 분할됨
- 삭제
  - 트리 노드가 너무 적은 포인터를 포함하면 노드 간의 엔트리가 재분배됨
  - 적어도 n/2 개의 자식 포인터를 가지도록 노드와 그 형제 노드들 사이의 포인터들을 재분배
  - 비단말 노드에 나타난 키 값이 단말 노드에도 나타나지 않을 수 있음

#### 비유일 검색 키

- 포함하는 레코드가 한 개 이상인 경우
- 레코드 삭제가 비효율적임
  - 특정 레코드와 일치하는 엔트리를 찾기 위해 잠재적으로 여러 개의 단말 노드를 검색해야 함
- 부가적인 속성 : 유일 식별자(nuiquifier) 속성 사용

### B+ 트리 확장

#### B+트리의 파일 구조

- 단말 노드는 레코드에 대한 포인터를 저장하는 대신에 레코드를 저장
- 공간 활용이 중요
  - 레코드에 의해 차지되는 공간이 키와 포인터에 의해 차지되는 공간보다 훨씬 많기 때문

#### 2차 인덱스와 레코드 재배치

- 레코드가 갱신되지 않아도 레코드의 위치를 바꾸는 경우 발생
- 모든 2차 인덱스들을 갱신하기 위해 다수의 입출력 연산을 필요로 할 수 있을 정도로 비용이 큼
- 주 인덱스 검색 키 속성의 값들을 2차 인덱스 레코드들에 저장
  - 2차 인덱스를 이용해서 특정 레코드를 찾기 위해 두 단계를 거쳐야 함
  - 갱신 비용을 획기적으로 줄일 수 있지만 엑세스하는 비용을 크다

#### 문자열 인덱시

- 접두어 압축(prefix compression) : 노드의 팬아웃을 늘릴 수 있음
  - 내부 노드에 검색 키 전체를 저장할 필요 없음 
  - 하위 트리들과 구별하는 데 충분한 만큼의 접두어를 검색 키에 취해 저장

#### B트리 인덱스 파일

- B트리 인덱스 : 검색 키 값의 중복된 저장 공간을 제거
  - 모든 검색 키 값은 단말 노드 어딘가에 나타남
  - 몇몇 검색 키 값을 비단말 노드에 반복적으로 나타남
- 적은 트리 노드로 인덱스 구성할 수 있음
- 비단말 노드에 각 검색 키를 위한 부가적인 포인터 필드를 추가해야 함
  - 단말 노드에 도달하기 전에 원하는 값을 찾을 수 있음

### 정적 해싱

- 버킷(bucket) : 한 개 혹은 보다 많은 레코드를 저장할 수 있는 저장 공간의 단위
- 해시 함수(hash function) h : K를 B에 대응시키는 함수
  - h(K) = B (버킷 주소)
  - 삭제하기 위해서는 버킷 주소를 검색해서 해당 레코드를 버킷으로부터 삭제

#### 해시 함수

- 분배는 균등해야 함(uniform) : 버킷에 같은 수의 검색 키를 할당
  - 균등하지 않으면 몇개의 버킷이 나머지 버킷보다 더 많은 레코드를 받음
- 분배는 임의적이어야 함(random)
- 잘 고안된 함수는 검색 키의 개수에 독립적인 상수의 평균 검색 시간을 제공

#### 버킷 오버플로우 처리

- 버킷이 충분한 공간을 갖고 있지 않은 경우
- 오버플로우 버킷 : 새로운 오버플로우 버킷을 제공하고, 레코드를 해당 버킷에 삽입
  - 오버플로우 체인(overflow chaining)
  - 오버플로우 버킷을 거지고 있으면 시스템은 모든 오버플로우 버킷에 있는 레코드도 조사해야 함
  - 닫힌 해싱(closed hashing)
- 열린 해싱(open hashing) : 오버플로우 체인이 없음
  - 선형 프로빙(linear probing) : 버킷이 차면 시스템은 초기의 버킷 집합에 있는 다른 버킷에 레코드를 삽입함
- 닫힌 해싱을 더 선호함 
  - 삽입 뿐만 아니라 삭제를 처리해야 하기 때문

#### 동적 해싱

- 정적 해싱
  1. 해시 함수를 현재 파일의 크기에 기초해서 선택 : 선택조건은 데이터베이스가 커짐에 따라 성능 저하
  2. 미래 어느 시점에 예상되는 파일의 크기에 기초해서 선택 : 초기에 상당한 공간이 낭비될 수 있음
  3. 주기적으로 해시 구조를 재구성
- 동적 해싱 (dynamic hashing) : 데이터베이스의 증대 혹은 축소를 조절하기 위해 해시 함수가 동적으로 변경되는 것
  - 확장성 해싱

#### 정적 해싱 대 동적 해싱

- 동적 해싱 
  - 파일이 커져도 성능이 감소하지 않음
  - 최소한의 공간 부담이 있음
  - 버킷을 미리 잡아둘 필요가 없고 버킷을 동적으로 할당
  - 단점
    - 검색을 할 때 부가적인 간접 단계를 수반
      - 엑세스하기 전에 버킷 주소 테이블을 먼저 엑세스

#### 비트맵 인덱스

- 다중 키를 가진 질의를 쉽게 하기 위해 고안된 특수화된 형태의 인덱스

  - 릴레이션에 있는 레코드는 0부터 시작해서 연속적으로 번호 매겨짐

- 비트맵 : 비트 배열

  - 가질 수 있는 각 값에 대해 하나의 미트맵을 구성함
  - 두 비트맵의 교집합은 and 수행

  - 삭제된 레코드를 구성하기 위해 존재 비트맵을 별도로 유지

### SQL에서 인덱스 정의

~~~sql
create index <name> in <relation> (<attribute set>);
~~~

~~~sql
drop index <name>;
~~~

