#### 10장

## 저장과 파일 구조

- 데이터베이스의 논리적 모델은 데이터베이스 사용자에 초점을 맞춘 단계
  - 시스템 사용자들에게 시스템 구현에 대한 물리적인 세부사항까지 알아야 하는 부담은 주어서는 안된다

### 물리적 저장 매체의 개관

- 캐시 : 가장 빠르고 비싸다. 크기가 상대적으로 작음
- 메인 메모리 : 연산에 이용할 수 있는 데이터를 저장하기 위한 저장장치. 
  
  - 정전이나 시스템 충돌이 발생하면 데이터를 잃어버림
- 플레시 메모리 : 정전이 발생해도 데이터가 남아있음 (비휘발성 : 전원이 공급되지 않는 상황에서도 저장된 데이터를 유지할 수 있음)
  - NAND, NOR 두 종류가 존재
  - 바이트 당 비용이 낮음

- 자기 디스크 저장장치 : 장기간 데이터를 저장하기 위한 매체
  - 데이터베이스가 자기 디스크에 저장됨
  - 데이터를 디스크에서 메인 메모리로 이동시키고, 원하는 연산을 수행, 변경된 데이터를 다시 디스크에 기록

- 광 저장장치 : CD, DVD

- 테이프 저장장치 : 데이터 백업과 보관용으로 사용

  - 자기 테이프가 디스크보가 저렴하지만 데이터 엑세스를 순차적으로 해야 하기 때문에 느림
  - 순차접근장치

- 속도와 비용에 따라서 계층으로 나타낼 수 있음

  - 계층의 높은 단게로 갈수록 비싸지만 빠르고, 낮은 단계는 비트단 비용은 감소, 엑세스 시간을 증가

  - 대부분 디스크에 엑티브 데이터를 저장

  1. 1차 저장장치(primary storage) : 캐시, 메인 메모리
  2. 2차 저장장치(secondary stroage) : 자기 디스크 등 (온라인 저장장치)
  3. 3차 저장장치(오프라인 저장장치) : 자기 테이프, 광디스크 주크박스

- 저장장치의 휘발성
  1. 휘발성 저장장치(volatile storage) : 정전이 발생하면 내용을 잃게 됨
     - 계층 구조에서 메인 메모리 위쪽으로는 휘발성 저장장치, 아래쪽은 비휘발성 저장장치
  2. 비휘발성 저장장치(Nonvolatile storage) : 데이터 보관

### 자기 디스크와 플래시 저장장치

#### 디스크의 물리적 특징

- 물리적으로 디스크는 판(platter)
  - 모터가 빠른 속도로 일정하게 회전
- 디스크 표면은 논리적으로 트랙(track)으로 나눔
  - 트랙은 다시 섹터(sector)로 나눔 : 읽고 쓸 수 있는 정보의 가장 작은 단위
- 헤드 : 자기 물질의 자화와 반대 방향으로 회전하면서 자기적으로 섹터 위의 정보를 저장
  - 헤드는 판 표면을 움직이며 다른 트랙으로 엑세스하도록 함
  - 기록 밀도를 증가시키기 위해 디스크 표면에 가능한 가까이에 유지됨
- 모든 디스크 판의 i번째 트랙을 i번째 실린더(cylinder) 라고 함

#### 디스크의 성능 측정

- 용량, 엑세스 시간, 데이터 전송속도, 신뢰성

1. 엑세스 시간(access time) : 요구를 받았을 때부터 데이터가 전송되기 시작할 때까지의 시간
   - 암을 정확한 트랙 위로 움직여야 함
   - 섹터가 암 아래에 나타날 때까지 기다림 = 탐색 시간(seek time)
2. 평균 탐색 시간(average seek time) : 임의의 요구를 측정한 탐색 시간들의 평균값
   - 섹터가 헤드 아래에 와서 엑세스될 수 있을 때까지 기다리는 시간 = 회전 지연시간(rotational latency time)
     - 평균 지연 시간(average latency time) : 디스크 전체 회전 시간의 2분의 1
3. 데이터 전송속도(data-transfer) : 데이터가 디스크로부터 검색되거나 디스크에 저장될 수 있는 비율
   - 바깥쪽 트랙이 안쪽 트랙보다 더 많은 수의 섹터를 포함
     - 실제 전송속도는 디스크의 안쪽 트랙에 대한 최대 전송속도에 비해 바깥쪽 트랙이 낮음
4. MTTF(Mean Time To Failure) : 시스템이 아무 실패 없이 계속해서 동작할 수 있는 시간
   - 신뢰성을 측정

#### 디스크 블록 엑세스의 최적화

- 각 요구는 참조되는 디스크 상의 주소로 나타남 = 블록 번호(block number)
  - 블록은 고정된 개수의 연속적 섹터들로 이루어진 논리적 단위
  - 디스크와 메인 메모리 사이의 데이터는 블록 단위로 전달
    - 플레시 메모리에서는 페이지(page) 단위
- 순차적 접근 : 같은 트랙 혹은 인접한 트랙에 있는 연속적인 블록을 대상으로 함
  - 디스크 탐색을 통해 척 번째 블록을 찾아야 함
- 임의 접근 : 각각의 요청을 탐색을 요구함
- 블록에 접근하는 속도 향상
  1. 버퍼링(buffering) : 나중의 요청을 대시해서 메모리 퍼너 내에 임시적으로 블록 저장
  2. 미리 읽기(read-ahead) : 블록에 대한 요청이 없더라도 올일 트랙 내의 연속적인 블록을 일단 메모리 내의 버퍼로 읽어옴
     - 블록 읽기를 할 때마다 회전 지연에 낭비되는 시간을 최소화
  3. 스케쥴링(scheduling) : 디스크 암의 움직임을 최소화
     - 디스크 암 스케쥴링 : 한번의 암 움직임을 통해 처리될 수 있는 엑세스의 수를 최대한 증가시키는 방식
       - 승강기 알고리즘
  4. 파일 구성 : 데이터가 엑세스되기를 기대하는 방식에 부합하는 방식으로 디스크 블록을 구성
     - 데이터가 파일로부터 삽입되거나 삭제된다면 재구성하는 데 드는 비용이 비쌈
     - 연속적인 블록을 한번에 파일에 할당
       - 시간이 지나면서 연속적인 파일은 단편화될 수 있음
  5. 비휘발성 쓰기 버퍼 : 데이터베이스 갱신에 대한 정보는 디스크에 기록되어야하기 때문에 대부분의 성능은 디스크 쓰기 속도에 달려있음
     - 해당 디스크에 대해 더 이상의 요구가 없거나 버퍼가 다 자체되면 디스크 목적지에 씀
  6. 로그 디스크 : 연속적인 로그를 기록하는 로그 디스크를 사용
     - 로그 디스크에 대한 엑세스는 연속적이어서 탐색 시간을 줄임
     - 저널링 파일 시스템
       - 따로 로그 시스템 없이 구현될 수 있음

#### 플래시 저장장치

- 디스크에 비해 더 빠름 임의 접근을 제공할 수 있음
  - 쓰는 작업은 수 ms가 요구됨
  - 직접적으로 덮어쓰기를 할 수 없음 : 해당 부분을 지우고 이어서 다시 쓰기를 수행
    - 페이지가 지워질 수 있는 횟수가 제한적
    - 느린 삭제 속도와 갱신의 제한 숫자로 인한 영향
      - 논리 페이지 숫자에서 물리적 페이지 숫자로 매필하는 것으로 최소화 : 논리 페이지가 수정될 때 이미 지워진 물리적 페이지로 재연결하고 기존의 위치의 데이터는 나중에 삭제
      - 논리 주소가 다른 물리적 주소로 재연결되면 기존의 물리적 주소는 지워져야 할 영역으로 확인됨
    - 빠른 접근을 위해 메모리 내의 변환 테이블(translation table) 유지
      - 지워지지 않은 페이지들에 대한 정보를 업데이트
    - cold data : 거의 업데이트 되지 않는 데이터
    - hot data : 빈번하게 업데이트 되는 데이터
    - wear leveling : 공고루 지움 연산을 분포시키게 하는 원리
    - FTL(Flash Translation Layer)에서 모든 동작 수행
- NOR 플래시 메모리는 워드 단위로 임의 접근하는 것을 허용, 메인 메모리와 비슷한 속도
- NAND 플랫 메모리는 데이터의 전체 페이지를 요구
  - 가격이 저렴하고 높은 용량 덕분에 더 많이 사용됨
  - 동일 블록 기반의 인터페이스를 제공

####RAID

- 많은 수의 디스크들이 병렬로 수행, 데이터를 읽거나 쓰는 비율을 향상시킬 수 있음
  - 중복된 정보가 여러 디스크에 저장될 수 있기 때문에 병렬화는 잠정적으로 데이터 저장의 신뢰성을 향상
  - 좀 더 높은 신뢰성과 성능을 위해 사용됨

- 신뢰성 : 중복(redundancy)
  - 디스크를 복사하는 것 : mirroring
    - 높은 신뢰성을 제공하지만 값이 비쌈
  - 매번 쓰기는 두 디스크 모두에 수행됨
  - 두 디스크 모두가 실패했을 때만 데이터 손실이 일어남
    - 하나를 쓰다가 정전 등이 발생하면 두 블록은 불완전한 상태가 될 수 있음 : 하나의 디스크에 쓰고, 그 다음에 다른 디스크에 씀
- 병렬화 : 일기 요구를 처리하는 비율이 두 배가 됨 : 시간당 읽기 횟수는 두 배
  - Striping : 데이터를 여러 디스크에 분산시켜서 전송속도를 향상시킬 수 있음
    - 비트 단위 분산 : 각 바이트의 비트들이 여러 디스크에 분산해서 구성
    - 블록 단위 분산

1. RAID 0 : 블록 단위로 분산
2. RAID 1 : 미러링 디스크
3. RAID 2 : 패리티 비트를 사용
   - 그 바이트 중에 1인 비트의 개수가 짝수개 혹은 홀수개인지를 기록
4. RAID 3 : RAID2 향상
5. RAID 4 : 블록 단계의 분산, 패리티 블록을 유지
6. RAID 5 : 패리티를 N+1 디스크 모두에 나누어 저장, RAID 4 향상

### 3차 저장장치

#### 광학 디스크

- DVD, CD
  - 헤드 조립대가 무겁기 때문에 자기 디스크보다 탐색 시간이 더 길다
  - 회전 속도는 자기 디스크보다 더 느리다
  - 데이터 전송속도는 자기 디스크보다 더 적다

#### 자기 테이프

- 영속적이고 많은 양의 데이터를 저장할 수 있지만 광학 디스크에 비해 느림

- 순차 엑세스로 제한됨

  - 2차 저장장치의 요구사항인 랜덤 액세스를 제공할 수 없음

  - 백업이나 자주 사용되지 않는 정보를 저장하기 위해 사용

- 테이프는 믿을 수 있는 읽기와 쓰기의 횟수가 제한되어 있음

#### 파일 구조

- 데이터베이스는 내부적으로 운영체제에 의해 관리되는 많은 다른 파일과 대응
  - 파일은 디스크안에 영구적으로 저장됨
  - 레코드들은 디스크 블록에 대응
- 각 파일은 블록이라고 불리는 고정된 길이의 저장 단위로 나누어짐
  - 저장장소 할당과 데이터 정송의 단위
  - 한 블록은 여러 레코드를 포함, 블록보다 큰 레코드는 없다고 가정
  - 각각의 레코드가 단이르 블록 내에 완전하게 포함되어야 함 : 데이터 항목에 접근하는 것을 단순화하고 속도를 향상

#### 고정된 길이의 레코드

- 고정된 길이 레코드를 사용하는 경우 문제점 
  1. 블록의 크기가 레코드 길이의 배수가 되지 않는다면 몇몇 레코드는 블록 경계를 넘게 됨
     - 레코드를 읽거나 쓰기 위해서는 블록 모두에 엑세스해야 함
     - 해결 : 남는 바이트는 사용하지 않고 남겨둠
  2. 레코드를 삭제하기 어려움
     - 삭제된 공간은 다른 레코드로 채워져야 함 : 삭제되었다는 표시를 해야 함
     - 삽입은 삭제보다 더 빈번히 일어남
     - 해결 : 파일 앞부분에 파일 헤드로서 몇 바이트를 할당
       - 파일에 대한 다양한 정보를 포함
       - 자유 리스트(free list) : 삭제된 레코드의 주소를 연결 리스트 형태로 구성
         - 헤드의 포인터를 다음 이용할 수 있는 레코드를 가리키도록

### 파일 안의 레코드 구조

- 파일 안에 어떻게 구성할 것인가
  1. 힙 파일 구조 : 레코드들의 순서가 업음
  2. 순차 파일 구조 : 검색 키에 따라 연속적으로 순서 저장
  3. 해싱 파일 구조 : 레코드의 몇몇 속성에 의해 계산됨

#### 순차 파일 구조

- 컴색 키를 기초로 한 정렬된 순서
  - 검색 키(search eky)는 특정 송성이나 속성들의 집합
  - 빨리 탐색하기 위해 레코드들을 포인터로 연결

#### 데이터 사정 저장장치

- 릴레이션에 대한 데이터도 유지 : metadata

  - 데이터 사전, 시스템 카탈로그

  1. 릴레이션 이름
  2. 속성의 이름
  3. 속성의 도메인과 길이
  4. 뷰의 이름과 정의
  5. 무결성 제약조건
  6. 권한이 부여된 사용자 이름
  7. 시스템 사용료에 대한 정보
  8. 사용자 인증을 위한 비밀번호 또는 다른 정보
  9. 각 릴레이션의 튜플 수 
  10. 각 릴레이션의 저장 메소드
  11. 릴레이션을 포함하고 있는 파일의 이름
  12. 인덱스 이름
  13. 인덱스된 릴레이션 이름
  14. 인덱스가 정의된 속성
  15. 형성된 인덱스의 형태

###데이터베이스 버퍼

- 디스크와 메모리 사이에 블록 전송 수를 최소화
- buffer : 디스크 블록의 복사본을 저장하기 위해 이용할 수 있는 메임 메모리의 일부분
  - 디스크 상의 복사복은 버퍼에 있는 버전보다 더 오래된 버전일 수 있음

#### 버퍼 관리자

- 디스크로부터 블록을 가져올 필요가 있을 때 버퍼 관리자를 호출
  - 해당 블록이 버퍼에 이미 있다면 메인 메모리에서의 블록 주소를 요구자에게 전달
  - 블록이 없다면 버퍼에 블록을 저장하기 위한 공간을 할당
- 모든 디스크 블록을 저장하기에는 메인 메모리가 부족함
  1. 버퍼 교체 전략 : LRU(least recently used) 방법을 사용
     - 최근에 가장 적게 참조된 블록을 디스크에 다시 쓰고 버퍼에서 제거
  2. 불박이 블록 : 디스크에 다시 쓰여지도록 허용되지 않는 블록(pinned)
  3. 블록 강제 출력 : 블록을 디스크에 다시 쓸 필요가 있는 경우

#### 버퍼 교체 방법

- n최근에 참조된 블록은 다시 참조될 가능성이 있다고 가정
  - 최근에 가장 적게 참조된 블록을 교체 : LRU
- 실제로 블록 교체를 위한 최적의 방법은 MRU(most recently used)
  - 현재 처리되고 있는 블록은 pin, 처리가 완료되면 붙박이 블록을 푼다.