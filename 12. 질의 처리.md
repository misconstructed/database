####12장

## 질의 처리

- 질의처리 : 데이터베이스로부터 데이터를 꺼내오는 것과 관련된 일련의 작업
  - 파일 시스템의 물리적 단계의 언어로 변환 하는 일
  - 질의 최적화를 위한 다양한 변환
  - 질의의 결과를 평가

### 개요

- 기본적인 단계 : 파신과 변환, 최적화, 평가
- 질의를 사용 가능한 형태로 변환해야 함 : 환장 관계 대수에 기반을 둔 표현
  - 주어진 질의 시스템 내부 표현 형태로 변환
- 파서 : 사용자가 만든 질의의 문법이 맞는지 확인, 질의에 나타나는 릴레이션 이름이 데이터베이스에 있는 릴레이션 이름인지 확인
  - 질의를 파스 트리 형태로 유지
    - 파스 트리를 관계 대수 표현으로 변환
    - 모든 뷰를 관계대수의 뷰를 정의하는 구문으로 변환

- 결과를 계산 
  - 하나의 질의가 여러 가지 SQL 문장으로 기술될 수 있음
  - SQL 질의도 여러 가지 관계 대수식으로 변환될 수 있음
  - 하나의 관계 대수식을 처리하는 다양한 방법이 존재

- 관계 대수식 내의 각 연산을 어떻게 처리할 것인지 주석(annotation)을 달아두어야 함
  - 연산의 수행을 위한 알고리즘
  - 사용하게 될 특정 인덱스 표시
  - 주석이 달려 있는 대수 표현 : 평가 기본 단위(evaluation primitive)
  - 질의처리를 위한 일련의 기본 연산들 : 질의 수행 계획(query execution plan), 질의 평가 계획(query-evaluation plan)
  - 질의 수행 엔지(query-execution engine) : 질의 평가 계획을 받아들이고, 계획을 수행, 질의에 대한 결과를 넘겨줌
- 서로 다른 질의 평가 계뢱들은 서로 다른 비용을 가지게 됨
  - 질의 비용을 최소화하도록 질의 평가 계획을 가짐
  - 질의 최적화(query optimization)
- 계획을 통해 평가되고 그 결과가 질의의 결과가 됨
  - 질의 최적기(query optimizer)는 각 연산의 비용을 알고 있어야 함
  - 실행을 위한 대강의 비용을 추정하는 것은 가능함
- 파이프하인(pipeline) 방식 : 다른 연산에서 나온 결과를 입력 튜플로 사용해서 다른 연산을 시작하는 방식

### 질의 비용의 측정

- 최선의 계획을 선택할 수 있는 것이 중요함
  - 연산들에 대한 비용을 추정해서 결합

- 질의 평가 비용 : 디스크 엑세스 횟수, CPU 사용 시간, 서로 다른 자원들의 소요 시간(통신 비용 등)

  - 규모가 큰 데이터베이스 시스템에서는 디스크의 자료에 접근하는데 드는 비용이 가장 중요함
    - 디스크 관련 작업이 매우 느리기 때문
    - CPU 시간은 무시하고 디스크 엑세스 비용만 이용해서 질의 수행 계획의 비용을 측정하기도 함
    - 전송된 블록의 개수와 디스크 탐색 횟수를 사용해서 비용을 계산

  - 블록 읽기와 쓰기 시간을 구별해야 함
    - 쓰기는 일반적으로 읽기보다 두 배 정도의 많은 비용이 든다
      - 쓰기 수행 수 쓰기가 성공했는지 검증하기 위해 섹터를 다시 읽음
    - 연산의 최종 결과를 디스크에 기록하는 비용은 비용 측정에서 고려하지 않음
  - 응답시간(response time) : 그 계획을 수행하는데 요구되는 벽시계 시간
    - 실제로 수행시켜보지 않고서는 추정하기 힘들다
      1. 응답 시간은 질의가 수행을 시작할 때 버퍼의 내용에 의존함
      2. 디스크 접근들이 어떻게 분포되는냐에 의존
    - 자원 소비를 최소화하려고 함

### 선택 연산

- 파일 스캔(file scan) : 데이터를 접근하는 최하위 단계의 연산
  - 선택 조건을 만족하는 레코드를 찾아서 꺼내오는 검색 알고리즘

#### 파일 스캔과 인덱스를 이용한 선택 연산

- 모든 튜플이 하나의 파일에 저장되어 있는 경우

1. 선형 검색 : 각 파일 블록을 스캔
   - 느리지만 어떤 파일에서도 적용될 수 있음

- 인덱스 : 데이터가 있는 곳을 알아내고 엑세스할 수 있는 경로를 제공
  - 접근 경로(access path)

2. 주 인덱스, 키에 대한 동등 비교
3. 주 인덱스, 키가 아닌 것에 대한 동등 비교 : 주 인덱스를 사용해서 여러 레코드를 받아올 수 있늠
4. 2차 인덱스, 동등 비교

- 인메모리 버퍼가 큰 경우, 레코드를 포함하는 블록이 이미 버퍼에 있을 수 있음
  - 버퍼가 큰 경우, 비용 추정치는 더 적을 수 있음
- 2차 인덱스는 레코드들에 대한 포인터가 저장되어 있지 않음
  - B+ 트리 파일 구조의 검색 키로 사용되는 속성들의 값이 저장됨
  - 2차 인덱스를 통해 레코드에 접근하는 것은 더 많은 비용이 든다
    - 2차 인덱스를 통해 주 인덱스 검색 키 값을 찾아서 검색

5. 주 인덱스 , 비교
6. 2차 인덱스, 비교
   - 끝 값까지 가장 낮은 수준의 인덱스 블록이 스캔됨
7. 논리곱
8. 논리합
9. 부정 : 조건을 거짓으로 만드는 튜플들의 집합
10. 하나의 인덱스를 사용한 논리곱 연산  : 인덱스를 사용할 수 있는 속성을 포함하는 조건이 있는 지 결정
    - 조건이 있는 경우 2~6 중 하나 선택해서 사용
11. 복합 인덱스를 이용한 논리곱 선택 연산 : 여러 개의 속성에 대한 인덱스를 사용할 수 있음
    - 1, 2, 3중 하나 사용
12. 식별자의 교집합을 이용한 논리곱 선택 연산
    - 각각의 단순조건과 연관이 있는 레코드 포인터를 사용하는 인덱스를 필요로 함
    - 포인터 집합을 통해 결과에 해당하는 실제 레코드를 얻어낼 수 있음
13. 식별자의 합집합을 이용한 논리합 선택 연산

### 정렬

- 결과를 정렬된 형태로 얻어낼 수 있도록 명시할 수 있음
- 동등 비교 연산은  입력 릴레이션이 정렬되어 있는 경우에 효율적으로 구현할 수 있음
- 릴레이션 내의 정렬 키에 대한 인덱스를 구축
  - 정렬된 순서로 읽어들일 수 있음
  - 논리적으로 정렬할 뿐, 물리적으로 정렬하진 않음
    - 레코드 하나당 한번의 디스크 접근을 수행할 수 있음 = 많은 비용
  - 물리적으로 정렬시키는 것이 바람직함

#### 외부 정렬-병합 알고리즘

- 메모리에 한번에 올라오지 못하는 릴레이션의 정렬 : 외부 정렬(external sorting)
- 외부 정렬-합병 알고리즘
  1. 여러 개의 정렬된 런이 생성됨
  2. 런이 합병됨(merge). 각 런에 대해 하나의 블록을 할당할 수 있음
     - 합병 단계의 결과는 정렬된 릴레이션이 됨
     - 디스크 쓰기 연산을 줄이기 위해 버퍼에 먼저 저장됨

### 조인 연산

#### 중첩 반봅 조인(nested-loop join)

- 중첩 반복 조인 알고리즘 : for 반복문으로 구성됨
  - 외부 릴레이션(r)과 내부 릴레이션으로 구성(s)
- 인덱스를 필요로 하지 않으며 어떠한 조인 조건에서도 사용될 수 있음
  - 결과에 반영하기 전에 반복되는 속성들을 제거하는 단계가 필요함
- 두 릴레이션의 모든 튜플 쌍을 검사하기 때문에 비용이 많이 든다.
  - 둘 중 하나의 릴레이션을 메인 메모리에 올릴 수 있다면 내부 릴레이션을 사용
    - 내부 릴레이션은 한번만 읽어 들이기 때문

#### 블록 중첩 반복 조인

- 버퍼가 작은 경우, 블록 단위로 릴레이션을 처리
- 성능 향상
  - 조인 속성이 내부 릴레이션의 키 속성인 경우, 첫 번째로 매치되는 결과를 찾자마자 내부 반복문을 종료할 수 있음
    - 키 속성을 중복되지 않기 때문
  - 외부 릴레이션에 대한 블록의 단위를 디스크 블록이 아니라 메모리에 올릴 수 있는 가장 큰 크기로 사용하면 성능 향상
  - 내부 반복문에서 한번은 앞쪽부터, 한번은 뒤쪽부터 스캔 : 스캔한 데이터를 재사용할 수 있음
  - 내부 반복문의 조인 속성에 대해서 인덱스가 존재하는 경우, 파일 스캔 대신 인덱스 검사를 진행

#### 색인된 중첩 반복 조인

- 인덱스 검색은 파일 스캔을 대치할 수 있음
- 구축된 인덱스를 사용하거나, 조인을 수행하기 위해 임시 인덱스를 만들어 사용할 수 있음

#### 합병 조인

- 자연 조인과 동등 조인을 계산하기 위해 사용됨
- 합병-조인 알고리즘
  - 각 릴레이션마다 하나의 포인터를 할당
    - 각 릴레이션의 첫 번째 튜플을 가리킴
    - 알고리즘이 진행되면서 포인터를 릴레이션 내의 다음 튜플로 이동
- 어느 하나도 조인 속성들에 대해 정렬되어 있지 않으면, 일단 정렬부터 수행하고 합병-조인 알고리즘을 수행함

#### 홉합 합병 조인

- 조인 속성에 대한 2차 인덱스가 구축되어 있는 경우
  - 정렬되지 않은 튜플들에 대해 변형된 합병 조인 연산을 수행할 수 있음
  - 인덱스를 통해 헤코드를 스캔하면 정렬된 순서로 레코드를 얻어낼 수 있음
- 합병 조인과 인덱스를 함께 사용
  - 정렬된 릴레이션을 2차 B+트리 인덱스의 단말 노드들과 합병
  - 정렬된 릴레이션의 튜플들과 정렬되지 않은 릴레이션의 튜플에 있는 주소를 포함

#### 해시 조인

- 해시 함수 h는 각 릴레이션의 튜플들을 분할하기 위해 사용
- 조인 조건을 만족시킨다 = 조인 속성에 대한 동일한 값을 가짐
  - 각 튜플은 해시함수를 통해서 분할영역에 포함됨
  - 동일한 분할영역에 대해서만 비교를 진행함
    - 조인 조건에 대해 같은 값을 가지고 있는지 테스트

- 오버플로우 처리
  - 조인 속성에 대해 같은 값을 가지는 튜플이 많아지는 경우
  - Skewed (치우쳤다) : 어느 영역에는 많은 튜플들이 들어가고, 다른 영역에는 적은 튜플들이 들어감
  - 오버플로우 분해(overflow resolution)  : 다른 해시 함수를 사용해서 더 작은 파티션으로 분할함

### 기타 연산

#### 중복 제거

- 정렬을 이용해서 중복제거를 쉽게 구현할 수 있음
  - 서로 인접해서 나타나게 되면, 하나만 남겨두고 나머지를 삭제할 수 있음
- 해시를 이용해서 중복 제거를 구현할 수 있음
  - 해시 함수를 이용해서 릴레이션을 분할
  - 분할 영역을 읽어들여서 메모리 내에 해시 인덱스를 구축, 중복 제거
- 중복 제거 비용을 비교적 크기 때문에, 명시적으로 중복 제거를 요청하도록하며, 그렇지 않은 경우 중복 제거를 하지 않음

#### 추축

- 추출 연산을 수행한 수 중복된 레코드를 없앤다

#### 집합 연산

- 합집합, 교집합, 차집합 등의 집합연산
- 릴레이션을 정렬한 후 릴레이션을 시캔하여 결과를 얻어냄으로써 구현
  - 두 릴레이션을 동시에 스캔
  - 릴레이션 내에 있는 동일한 튜플을 가려내서 결과에 반영
- 정렬되어 있지 않은 경우, 정렬을 먼저 수행
  - 해시 인덱스를 구축, 해시 인덱스 내에서 비교

#### 외부조인

1. 대응되는 조인을 수행한 후에, 그 결과에 나머지 튜플들을 추가
   1. 조인을 수행하고 임시 릴레이션에 추가
   2. (외부 릴레이션) - (임시 릴레이션) 을 수행해서 나온 결과를 null 값과 함께 결과에 추가
2. 조인 알고리즘을 수행하고, 내부 릴레이션에 있는 어떤 튜플과도 조인되지 않은 튜플을 null값을 추가해 결과에 추가

#### 통합과(aggregation)

- 통합화 연산은 중복 제거와 동일한 방법으로 구현될 수 있음
  - 정려롸 해시를 사용
  - 튜플들을 제거하지 않고 대신 이 튜플들에 통합화 연산을 적용
- 중복 제거 연산의 비용과 통일

### 표현식의 평가

- 적장한 순서로 한번에 하나씩의 연산을 평가
  - 각 평가 결과는 임시 릴레이션에 실체화 되어 사용될 수 있음
  - 임시 릴레이션을 생성해서 디스크에 써야한다는 단점

#### 실체화(materialization)

- 연산자 트리(operator tree) 
  - 식의 가장 낮은 단계의 연산들부터 수행함
  - 낮은 단계의 연산에 대한 입력을 데이터베이스 내의 릴레이션들임
    - 결과를 임시 릴레이션에 저장
- 실체화 평가 : 각각의 중간 연산의 결과과 생성된 후 실체화되고 다음 단계의 연산을 위해 사용됨
  - 중간 결과를 디스크에 쓰는 비용도 포함해야 함

#### 파이프 라이닝

- 임시 파일 수를 줄임

  - 질의 처리 효율성을 향상시킬 수 있음
  - 연산들을 합침으로써 임시 파일의 개수를 줄일 수 있음

- 연산 결과로 하나의 튜플을 만들어 낼 때마다 그 튜플을 다음 연산의 입력으로 넘겨줌

  - 임시 릴레이션들을 읽고 쓰는 비용을 제거

- 구현

  1. 요구 구동 파이프라인(demand driven pipeline) : 상층부에 있는 연산들로부터 튜플들에 대한 요구를 반복시키게 됨

     - 각 연산이 튜플 요구를 받아들일 때마다 각 연산은 다음 튜플을 계산한 후 그 결과를 넘겨줌
     - 위에서 아래에 있는 데이터를 끌어올리는 것(pulling)
     - 요구가 있을 때에만(lazy) 만들어 냄

     - 구현의 편리성 때문에 더 많이 사용됨

  2. 생상자 구동 파이프라인(producer driven pipeline) : 요구를 기다리지 않고 미리 연산을 수행해 결과 튜플을 만들어 둠

     - 아래에서 위로 데이터를 밀어 올리는 것(pushing)
     - 미리 튜플들을 만들어냄

