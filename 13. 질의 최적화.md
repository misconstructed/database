#### 13장

## 질의 최적화

- 질의 최적화(Query optimization)  : 수많은 질의 수행 계획 중에서 가장 효율적인 실행 계획을 선택하는 과정
  - 관계 대수 단계에서 주어진 식과 동등하면서 보다 효율적으로 수행될 수 있는 식을 시스템이 찾아냄
  - 어떤 연산을 수행하기 위한 알고리즘의 선택이나 특정 인덱스 사용 등과 같은 질의 처리의 자세한 방법을 선택

### 개요

- 동등한 식이지만 중간 결과를 더 작게 만들어 주는 것이 효율적임
- 수행 계획 : 연산의 수행이 어떠한 식으로 진행되어야 하는지를 정확하게 정의하는 것
  - 주어진 과계 대수식을 가장 적은 비용으로 동일한 결과를 만들어내는 질의 수행 계획을 찾아내는것이 질의 최적기의 역할
  - 같은 결과를 출력하는 다른 질의 수행 계획들을 만들어낼 필요가 있음
    1. 논리적으로 주어진 식과 동등한 식을 만들어 냄
    2. 여러가지 방법의 주석을 달아 서로 다른 질의 수행 계획을 만든다.
    3. 비용을 추정하고 비용이 가장 적은 것을 선택
  - 릴레이션 크기, 인덱스 깊이 등 릴레이션에 관한 통계 정보를 수집해서 수행 계획의 비용 추정이 이루어짐
  - 수행 계획 확인 : <code>explain <query></code>
- 동등 규칙(requivalence rules)을 사용해서 동등한 식을 만들어 냄

### 관계형 식의 변환

- 하나의 질의는 여러 개의 다른 방법으로 표현될 수 있음
  - 동일한 결과 튜플 집합을 만들어 낼 때 두 걔의 관계 대수식을 동등하다(equivalent)
  - 입력과 출력은 튜플의 다중 집합(multiset)
    - 다중 집합 버전의 관계 대수가 사용됨

#### 동등 규칙

- 두 가지 형태의 식이 동등하다는 것을 나타냄
  - 논리적으로 동등한 다른 식으로 기존의 식을 변환할 수 있음

1. 논리곱은 각각의 선택 연산들로 분해
2. 선택 연산은 교환 법칙이 성립
3. 추출연산 중 마지막 연산만 필요하고 나머지는 생략 가능
4. 선택 연산은 카티션 곱과 세타 조인으로 변환
5. 세타 조인은 교환 법칙이 성립
6. 자연 조인 연산은 결합 법칙이 적용
7. 선택 연산은 조인 연산에 의해 배분될 수 있음
   1. 조인에 참여하는 두 식 중 하나의 식에만 선택 조건이 관련 있는 경우
   2. 첫번째 선택 조건이 첫번째 속성에만 관련이 있고, 두번째 선택 조건이 두번째 속성에만 관련이 있는 경우
8. 추출 연산은 세타 조인연산에 의해 배분될 수 있음
9. 합집합과 교집합 연산은 교환 법칙이 성립함
   - 차집합 연산은 교환 법칙이 성립하지 않음
10. 합집합과 교집합 연산은 결합 법칙이 성립
11. 선택 연산은 합, 교, 차집합 연산에 분배될 수 있음
12. 추출 연산은 합집합 연산에 분배될 수 있음

- 동등 규칙들의 조합으로 다른 규칙이 생성됮 않은 때, 동등 규칙들의 집합 = 최소 결합(mimimal set)
  - 질의 최적기는 최소 집합인 동등 규칙 집합을 사용함

#### 조인 순서

- 임시 중간 결과의 크기를 줄이기 위해서는 조인 연산의 순서가 매우 중요함
  - 질의 최적기는 조인 순서에 많은 주의를 기울임
- 자연 조인은 교환 법칙이 성립함
- 카티션 곱을 이용하면 커다란 임시 릴레이션을 생성하게 됨

#### 동등 식의 열거연산

- 동등한 식을 만들어 내기 위해서 동등 규칙을 사용함

  1. 처음에는 동등한 식의 집합 EQ에는 E만 포함됨

  2. EQ에 포함된 모든 식에 대해서 동등 규칙을 적용함

  3. 새롭게 생성된 식은 EQ에 추가됨

  4. 더 이상 새로운 식이 생성될 수 업을 때까지 반복됨

  - 시간적으로 공간적으로 비용이 매우 많이 드는 과정임

- 질의 최적기가 사용하는 방법

  1. E1에서 E'을 만들어내는 경우, 두 식은 e1과 e1의 변환식을 제외하면 같은 부분식을 가지게 됨 = 동일한 부분식을 많이 공유함
     - 두 식이 공유하는 부분식을 가리키도록 만들면 필요한 공간을 줄일 수 있음
  2. 비용 추정을 고려한다면 몇몇 식들은 검사할 필요가 없어짐

### 결과의 통계정보 추정

- 연산의 비용은 연산의 입력의 크기와 기타 통계정보에 의존적인
  - 데이터베이스 릴레이션의 통계정보를 나열, 연산 결과에 대한 통계정보를 추정
- 최소 비용으로 추정된 질의 수행 계획이 실제로 최소 비용을 수행하지 않을 수 있음

#### 카탈로그 정보

- nr : 릴레이션 r의 튜플 수 
- br : 릴레이션 r의 튜플들이 차지하는 블록 수
  - 하나의 파일에 저장된 경우 br = nr / fr
- Ir : 릴레이션 r의 하나의 튜플의 바이트 크기
- fr : 한 블록에 들어가는 릴레이션 r의 튜플 수
- V(A, r) : 속성 A에 대해서 릴레이션 r에서 나타나는 서로 다른 값의 개수

- 인덱스에 대한 통계 정보도 카탈로그에 유지

  - 정확한 통계정보를 유지하고자 하면, 릴레이션이 변경될 때마다 통계정보도 갱신해야 함
  - 갱신은 그에 따른 부담이 있음 = 매번 통계정보를 수정하지 않음
    - 시스템의 부하가 적은 동안에 통계정보를 생식
      - 통계정보는 정확한 정보는 아닐 수 있음

- 각 속성의 분포(distribution)를 히스토그램으로 가지고 있음

  - 히스토그램은 적은 공간을 차지감

  1. 등폭 히스토그램(equi-width histogram) : 값의 범위를 같은 크기의 구간들로 나눈 것
  2. 동심 히스토그램(equi-depth histogram) : 각 구간이 같은 수의 값을 갖도록 구간들의 경계를 조정

#### 선택 크기 추정

- 선택 연산의 결과의 크기 추정을 선택 술어에 의존적임

- A=a 인 경우

  - 균등 분포를 가정하는 것이 올바르지 않은 경우가 종종 있지만 균등 분포 가정이 합당한 경우가 많음
  - 균등 분포 가정은 설명을 상대적으로 단순화시킴
  - nr / V(A, r)

- A <= a 인 경우

  - 속성 A에 대한 최소값과 최대값은 카탈로그에 저장되어 있음

  1. a < min(A, r) 인 경우 결과는 0
  2. a >= max(A, r) 인 경우 결과는 nr
  3. 나머지 경우 nr * (v - min(A, r)) / (max(A, r) - min(A, r))

- 복잡합 선택 연산

  - 논리곱
    - 조건을 만족하는 튜플이 릴레이션이 존재한 확률은 si / nr
      - 선택도(selectivity)
      - 선택 연간의 결과 퓨플 수 = nr * (s1 * s2 * ... * sn) / nr
  - 논리합 : 단순 조건을 만족하는 모든 레코드의 합집합
  - 부정 : 선택 연산을 만족시키지 않는 튜플들

#### 조인 크기 추정

- 카티션 곱 r x s : nr * ns 개의 튜플 보유
  - 카티션 곱의 튜플의 크기 : lr + ls

1. 교집합이 공집합인 경우 = 공유되는 속성이 업는 경우 자연조인의 결과는 카티션 곱의 결과와 동일함
2. 교집합이 r 의 키 속성인 경우, 하나의 튜플은 많아야 r에 있는 나타의 튜플과 조인됨
   - 자연 조인의 결과는 릴레이션 s에 있는 튜플 수보다 작게 됨
3. 교집합이 두 릴레이션의 키가 아닌 경우 : nr * ns . V(A, r)

#### 다른 연산들에 대한 크기 추정

1. 추출 : V(A, r)
2. 집계 : V(A, r)
3. 집합 연산 
   - 동일한 릴레이션인 경우 두 조건의 합집합으로 계산
   - 동일한 릴레이션에 대한 선택 연산이 아닌 경우, 두 릴레이션의 크기의 합으로 ㅊ전함
     - 정확하지는 않지만 크기의 상한(upper bound)를 제공한다
4. 외부 조인 : 두 속성의 자연 조인의 크기에 r의 크기를 더한 값으로 추청

### 수행 계획의 선택

- 수행 계획은 각 연산에 어떠한 알고리즘을 사용할 것인지, 어떻게 연산들을 배치해서 질의를 수행할 것인지 정의
- 비용 기반 질의 최적기(cost-based optimizer)는 주어진 질의에 대해서 가능한 모든 질의 수행 계획을 고려, 비용이 가장 적게 드는 계획을 선택함
  - 대부분의 질의 최적기는 질의 최적화 비용을 줄이는 방법을 사용함
  - 가장 적합한 계획을 찾기 못할 수도 있음

#### 비용 기반 최적화

- 대부분의 질의는 where절에 명시되어 있는 조인 조건과 선택 연산을 이용해 구성
- 조인 : n개의 릴레이션을 가지는 경우 2(n-1)! / (n-1)! 개의 서로 다른 조인 순서를 가짐
  - 부분적으로 조인을 한 결과 릴레이션이 작은 경우 더 적은 비용으로 수행 가능함
  - 동적 프로그래밍(dynamic programming) 알고리즘을 사용할 수 있음
    - 계산 결과를 저장해 두고 그 결과를 다시 사용함
    - 프로시져는 계산한 수행 계획을 릴레이션들의 집합으로 색인된 배열에 저장
      - 인덱스를 사용해서 튜플을 식별 또는 전체 릴레이션을 스캔
  - 여러 릴레이션을 포함하는 경우, 교집합이 없는 두 개의 부분 집합으로 분할
    - 각각에 대해 최적의 수행 계획을 재귀적으로 찾고, 비용을 계산
    - 조인의 순서는 이후의 저인의 비용에 영향을 줄 수 있기 때문

#### 동등 규칙을 이용한 비용 기반 최적화

- 조인 이외의 요소를 처리하기 위해 경험적 변형을 이용
  - 각 질의 최적기에 따라 다름
- 동등 규칙을 사용해서 새로운 규칙을 쉽게 적용할 수 있음
  - 물리적 동등 규칙(physical equivalence rules) 
    - 조인과 같은 논리 연산을 해시 조인이나 nested-loops 조인과 같은 물리적 연산으로 바꿀 수 있음

#### 경험적 최적화

- 최적화 비용을 줄이기 위해 경험적 방법(heuristics)을 사용함
  - 경험적 최적기는 변환을 비용이 줄어드는지 알아보지 않고 규칙을 적용

1. 선택 연산을 가능하면 일찍 수행하라
2. 추출 연산을 일찍 수행해라
   - 추출 연산보다 선택 연산을 더 일찍 수행하는 것이 성능향상에 더 도움이 됨
   - 선택 연산을 릴레이션의 크기를 큰 폭으로 줄일 수 있음

- 질의 최적화를 위해서 비용 예산을 명세할 수 있음
  - 최적화 비용 예산(optimization cost budget)을 넘는 순간에 중단됨, 그때까지 찾은 계획 중에서 가장 최적의 계획을 출력함
    - 지금까지 찾은 계획이 꽤 적은 비용으로도 가능하다면 질의를 최적화하는 데 더 이상 시간을 보낼 필요가 없음
- 처음에는 계획을 찾기 위해서 비용이 적은 경험적 방법을 사용
  - 찾아긴 계획을 기반으로 예산을 가지고 비용 기반 최적화를 시작
- 대부분 프로그램은 상수값을 달리 하여 같은 질의를 반복적으로 수행
  - 상수값으로 얼마자 주어지든 상관없이 해당 질의를 한 번 푀적화하고 수행 계획은 캐싱
  - 초기의 상수값에 대한 최적의 계획과 다를 수 있지만 경험적으로 캐싱된 계획이 재사용
    - 질의 수행 계획 캐싱(plan caching) : 질의 수행 계획의 재사용

#### 중첩된 하위 질의의 최적화

- where 절에 있는 중첩된 하위 질의를 인자로 받아서 하나의 값이나 집합으로 결과를 제공
  - 외부 from 절에 있는 릴레이션들의 카티션 곱을 게산하고, where 절의 술어를 통해 카티션 곱의 각 튜플을 조사함
- 연관된 계산(correlated evaluation) : 중첩 하위 질의를 가지는 질의의 이러한 계산 기법
  - 하위 질의가 외부 질의의 각 튜플에 대해 각각 계산되므로 효율적이지 못함
  - 최적기는 가능하면 중첩 하위질의를 조인으로 변환
  - 변환이 불가능한 경우, 하위 질의를 독립적인 식으로 유지하고 따로 최적화한 후, 연관된 계산에 의해 질의 처리
    - 중첩된 질의의 결과를 담고 있는 임시 릴레이션을 생성, 임시 릴레이션과 외부 질의를 조인하면서 결과를 얻어냄
  - 연관성 제거(decorrelation) : 중첩 질의를 임시 릴레이션과 조인이 포함된 질의로 변환하는 과정
    - 복잡한 중첩 하위 질으의 최적화는 어려운 작업
    - 대부분의 최적기들은 제한된 부분에 대해서만 연관성 제거를 수행

###실체화 뷰(materialized view)

- 데이터베이스는 뷰가 정의될 때, 뷰를 정의하는 질의만을 저장함
- 실체화 뷰는 내용이 계산되어 저장되어 있는 뷰를 의미함
  - 중복되는 데이터로 구성됨

#### 뷰 관리

- 뷰 정의에서 사용되는 데이터가 변경될 때마다 실체화 뷰가 최신 데이터로 변결되어야 함

  - 뷰 관리(view maintenance)

- 뷰 정의에 선언되어 있는 각 릴레이션에서 삽입, 삭제, 갱신이 일어날 때마다 작동하는 trigger를 정의

  - 변경사항을 교려하여 실체화 뷰의 내용을 수정

  1. 가장 단순한 방법은 전체 뷰를 다시 계산
  2. 점진적 뷰 관리(incremental view maintenance) : 영향을 받은 부분에 대해서만 실체화 뷰를 갱신
     - 변경될 때 뷰의 내용을 점진적으로 갱신
  3. 즉각적 뷰 관리(immediate view maintenance) : 갱신 트랜젝션의 일부로써 점진적 뷰 관리가 이루어짐
  4. 지연된 뷰 관리(deferred view maintenance) : 뷰 관리를 다음으로 미룸
     - 갱신 트랜젝션 처리에 드는 부하를 줄일 수 있음

#### 점진적 뷰 관리

- 데이터베이스를 인관적이지 않게 만드는 연산은 삽입, 삭제, 갱신
  - 튜플의 삽입과 삭제를 고혀애햐 함
  - 변경 사항 = 차이점(differential)

- 조인 연산
  - 새 튜플을 삽입하는 경우
    - 자연조인의 결과 튜플들을 실체화 뷰의 변경 전 내용에 추가

- 집계 연산
  1. count : 그룹에 값이 존재하는 경우 그 그룹의 카운트 값을 1 증가
     - 카운트 값이 -이 되는 경우 실체화 뷰로부터 튜플을 삭제
  2. sum : 카운트 값을 유지하지 않으면, 합계가 0인지 그룹에 속하는 튜플이 존재하지 않는건지 확인할 수 없음
  3. avg : sum, count 값을 유지해서 합을 개수로 나누어 평균을 계산
  4. min, max : 최소값에 해당하는 튜플이 삭제되는 경우, 새로운 최소값을 찾아내기 위해서 r에 있는 그룹 내의 튜플들을 모두 조사해야 함

#### 실체화 뷰와 인덱스 선택

- 실체화 뷰 선택(materialized view selection) : 실체화해야 할 최적의 뷰 집합은 무엇인가
  - 시스템 부하(workload) 기반으로 이루어져야 함
  - 부하는 일련의 질의와 갱신 작업으로 생김
- 인덱스는 데이터로부터 만들어지며 질의의 속도를 향상시키고, 생신 작업을 느리게 함
  - 인덱스 선택(index selection) 문제는 실체화 뷰의 선택 문제와 밀접한 관계가 있음

