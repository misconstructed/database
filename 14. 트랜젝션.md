#### 14장

## 트랜젝션

- 여러 연산들이 사용자 관점에서는 하나의 단위로 보이는 경우
  - 전체가 정상적으로 수행되거나, 도중에 실패한 경우 어떠한 연산도 일어나지 않는 상태로 되돌려야 함
- 하나의 논리적 작업 단위를 이루는 연산들의 집합을 트랜젝현이라고 함
  - 트랜젝션의 모든 연산이 실행 완료하거나 그렇지 않으면 하나도 실행되지 않음
  - 트랜젝션들의 동시 실행을 지원해야 함

### 트랜젝션 개념

- 데이터 항목들을 엑세스하고 갱신하는 프로그램 수행의 단위

  - <code>begin transaction</code>, <code>end transaction</code> 사이에서 실행되는 모든 연산들은 하나의 나눌 수 없는 단위로 보여져야 함
  - 전부가 실행되던지 전부가 실행되지 않아야 함
    - 실패하면 모든 변경을 되돌려 져야 함 = 원자성(atomicity)

  - 여러 데이터베이스 연산으로 구성되어 있는 것처럼 보여서는 안됨

- 고립성(isolation) : 동시에 수행되는 다른 데이터베이스 명령의 영향을 받지 않고 한 트랜젝셩이 올바로 수행되는 것을 보장

- 지속성(durability) : 활동은 장애가 발생해도 지속적으로 남아야 함

- 일관성(consistency) : 무결성 제약조건 등 애플리케이션 자체의 일관성 조건을 보존해야 함

- ACID 성질

#### 간단한 트랜젝션 모델

- read(x) : ㅌ튼젝션의 메인 메모리 버퍼에 있는 x라는 변수로 전송
- write(x) : 메인 메모리 버퍼에 있는 변수 x의 값을 데이터베이스 데이터 항목 x로 전송
- 데이터 항목에 대한 수정이 메인 메모리 상에만 반영되었는지, 디스크 상의 데이터베이스에 기록되었는지 판단하는 것이 중요
  - write 연산에 의한 중간 갱신 결과를 다른 곳에 임시로 저장했다가 나중에 디스크에 기록함

- 실패가 발행한 시스템 = 비일관성 상태(inconsistent state)

  - 트랜젝션의 어느 한 시점에서 보면 시스템이 비일관성 상태에 있을 수 있음
    - 비일관성 상태는 트랜젝션을 실행하는 동안을 제외하고 나타나지 않아야 함

- 갱신하는 데이터의 예전 값을 로그(log)에 기록

  - 정상적으로 종료하지 못할 경우 데이터베이스 시스템을 로그를 사용해 데이터의 예전 값으로 복구

- 지속성 : 트랜젝션이 성공적으로 끝나면 종료된 이후에 시스템 오류가 발생하더라고 그 트랜젝션이 실행 동안에 처리한 모든 갱신 결과가 데이터베이스에 지속되어야 함

  - 디스크에 기록된 데이터는 보존됨

  1. 갱신이 트랜젝션이 완료되기 전에 데이터베이스에 기록됨
  2. 실패한 트랜젝션의 갱신 결과를 다시 만들어 낼 수 있을 만큼 갱신에 대한 정보다 충분

- 고립성 : 순차적으로 트랜젝션을 실행하면 됨

  - 하지만 동시 수행은 상당한 성능상의 이점을 제공함 = 다중 트랜젝션들이 동시에 수행되도록 허용해야 함

### 저장 장치의 구조

1. 휘발성 저장 장치 : 시스템 장애 시에 데이터 손실
   - 메인 메모리와 캐시 메모리 등
   - 직접 접근이 가능하기 때문에 빠르다
2. 비휘발성 저장 장치 : 시스템 장애 시에도 데이터가 보존됨
   - 자기 디스크, 플래시 저장장치
   - 랜덤 엑세스하는데 있어서 상대적으로 느리다
3. 안정 저장 장치 : 안정 저장 장치에 저장되면 데이터는 절대 손실되지 않음
   - 데이터 손실이 거의없도록 하는 기술로 근접하게 구현

### 트랜젝션 원자성과 지속성

- 트랜젝션 중단(abort) : 트랜젝션의 실패, 데이터베이스의 상태에 아무런 영향도 주지 않아야 함
  - 롤백(rollback) : 갱신 내용은 모두 이전 상태로 복구됨
    - 주로 로그를 유지해서 구현됨
    - 데이터베이스 수정은 먼저 로그에 기록됨, 이후에 데이터베이스가 갱신됨
      - 로그를 유지해서 갱신을 되돌릴 수 있고, 갱신을 재수행할 수 있음
- 커밋(commit) : 성공적으로 실행을 완료한 트랜젝션
  - 상태는 시스템에 오류가 발생하더라도 지속됨
  - 보상 트랜젝션 : 커밋된 트랜젝션의 영향을 취소하는 방법
    - 항상 만들 수 없고, 사용자가 해야 하는 부분
- 트랜젝션의 상태
  - 동작 : 초기 상태
  - 부분 커밋 : 마지막 명령문이 실행된 후의 상태
  - 실패 : 더 이상 진행될 수 없을 때
    - 실패가 발생해도 갱신 내용이 다시 수행될 수 있도록 충분한 정보를 디스크에 저장됨
  - 중단 : 트랜젝션 시작 전 상태로 환원되고 난 후의 상태
  - 커밋 : 성공적으로 완료된 후의 상태
  - 커밋되거나 중단된 경우 해당 트랜젝션은 종료(terminated) 되었다고 함
- 소프트웨어 오류로 인해 중단된 경우는 트랜젝션을 재시작 가능함 = 새로운 트랜젝션으로 인식
  - 트랜젝션을 강제 종료 시킬 수 있음
- 관찰 가능한 외부 출력 : 추렭을 트랜젝션이 커밋 상태에 들어간 다음에 일어나도록 함
  - 외부 출력과 관련된 값들을 데이터베이스의 특수 테이블에 임시로 저장한 다음 트랜젝션이 커밋 상태로 들어가면 실제 외부로 출력을 수행

### 트랜젝션 고립성

- 트랜젝션들이 동시에 수행되는 것을 허용함
  - 동시성과 일관성을 보장해야 함

1. 처리율과 자원 이용률 향상
   - 입출력을 하는 동안 프로세서는 다른 작업을 수행할 수 있음
   - 시스템 처리율 : 주어진 시간에 처리되는 트랜젝션의 수
     - 시스템 처리율을 높여준다
   - 프로세서와 디스크 이용률 또한 증가

2. 대기 시간 감소
   - 짧은 트랜젝션들이 긴 트랜젝션이 끝날 때까지 오랜 시간을 기다려야 함
   - 평균 응답 시간 : 요청된 후에 완료될 때까지 걸리는 평균 시간
     - 평균 응답 시간을 줄일 수 있음

- 다중 프로그래밍

  - 동시에 수애되지 않는 경우 일관성은 깨질 수 있음
  - 동시서 제어 기법이 필요함(concurrency-control scheme)
    - 실행 순서 = 스케쥴
      - 트랜젝션들이 어떠한 순서에 따라 실행되는지를 보여줌

- 순차적인 스케쥴

  - n개의 트랜젝션들에 대해 n! 개의 서로 다른 정상적인 스케쥴들이 나올 수 있음
    - 여러 트랜젝션을 동시에 수행하면 더 이상 순차적이지 못함
  - 한 트랜젝션을 수행하다가 문맥 전환을 일으켜서 다른 트랜젝션을 일정 시간 수행하고 다시 문맥 전환
  - 데이터베이스 시스템이 일관된 상태에 있도록 스케쥴을 실행 : 동시성 제어 컴포넌트가 해당 역할 수행

  - 하나씩 순차적으로 수행하는 스케쥴의 실행 결과와 동일한 스케쥴 = 직렬(serializable) 스케쥴

### 직렬성

- 순차적 스케쥴은 반드시 직렬성을 갖는다

- 출동 직렬성(conflict serializability)

  - 서로 다른 데이터 항목을 엑세스 하는 경우 두 명령어의 순서를 바꿀 수 있음

  - 같은 데이터 항목을 접근하는 경우

    1. read, read : 문제 없음
    2. read, write : 순서에 영향, 문제 있음
    3. write, read : 순서에 영향, 문제 있음
    4. write, write :  순서에 영향, 문제 있음

    - 최소 하나가 write인 경우 두 트랜젝션은 서로 충돌 함(conflict)

  - 충돌이 일어나지 않는 명령어들의 순서를 바꿔서 다른 스케쥴로 변경이 가능하면, 두 스케쥴을 충돌 동등(conflict equivalent)

    - 순차 스케쥴에 충돌 동등하면 해당 스케쥴은 충돌 직렬적

  - 우선순위 그래프

    - T1 -> T2 : T1은 반드시 T2보다 먼저 실행되어야 한다
    - 해당 그래프에서 사이클이 존재하면 두 스케쥴을 충돌 직렬적인 스케쥴이 아님

### 트랜젝션 고립성과 원자성

#### 복구 가능한 스케쥴

- 부분 스케쥴 : commit 또는 abort 명령이 업는 경우
- 복구 가능한 스케쥴 : T1가 이전에 기록한 데이터 항목을 T2가 읽은 경우, T1의 커밋 연산이 T2의 커밋 연산보다 먼저 발생해야 함

#### 비연쇄적인 스케쥴

- 하나의 트랜젝션이 취소됨으로써 일련의 트랜젝션들이 따라서 취소되는 형상 : 연쇄적 롤백(cascading rollback)
  - 상당히 많은 양의 작업이 취소됨

#### 트랜젝션 고립성 수중

- 직렬성은 프로그래머가 코드를 작성할 때에 동식성을 고려하지 않도록 해줌

  - 직렬성을 보장하기 위한 규약이 어떤 애플리케이션에서는 동시성을 거의 허용하지 않는 경우가 발생할 수 있음
    - 약한수준의 일관성이 이용됨

- 고립성 수준

  1. serializable : 직렬적 실행을 보장
  2. repeatable read : 단지 커밋된 레코드만 읽을 수 있고, 두 번 읽는 사이에 다른 트랜젝션이 해당 레코드를 갱신하지 못하도록
     - 중간에 새로 삽입된 레코드가 검색될 수 있음 = 팬텀 현상(phantom phenomenon)
  3. read committed : 커밋된 레코드만 읽을 수 있음, 반복 읽기는 요구되지 않음
     - 다른 트랜젝션에 의해 갱신될 수 있음
  4. read uncommitted : 커밋되지 않은 데이터도 읽음
     - 가장 낮은 수준의 고립성

  - 더티 기록(dirty write) 은 허용하지 않음
    - 커밋 또는 중단되지 않은 다른 트랜젝션이 기록한 데이터 항목에 대한 기록을 허용하지 않음
  - <code>set transaction isolation level serializable;</code>

- 자동 커밋 기능이 기본적으로 사용된다면 해제해야 함 : setAutoCommit(false)

### 고립성 수준의 구현

- 트랜젝션 처리에 적합한 스케쥴을 생성하는 동시성 제어 기법이 있음

#### 락킹

- 사용해야 할 데이터 항목만 라킹
- 2단계 라킹 규약
  1. 락을 획득하기만 하고 해제하지는 않는 단계
  2. 락을 해제하기만 하고 획득하지는 않는 단계
- 락의 종류
  1. 공유 : 읽을 때 사용
  2. 베타 : 기록할 때 사용

#### 타임 스탬프 

- 트랜젝션이 시작할 때의 타임스탬프를 부여

  - 각 항목에 타임스탬프를 부여

  - 데이터 항목에 대해 두개의 타임스탬프를 유지

    1. 읽기 타임스탬프 : 읽을 트랜젝션의 타임스팸프를 유지
    2. 쓰기 타임스탬프 : 현재 값을 기록한 트랜젝션의 타임스탬프

    - 트랜젝션이 데이터 항목에 대한 접근이 충돌될 때 트랜젝션 타임스탬프 순서로 접근하도록 하는 데에 사용

#### 다중 버전과 스냅샷 고립

- 데이터 항목에 대한 한개 이상의 버전을 유지
  - 나중에 스탠젝션이 기록한 새 버전이 아닌 이전 버전을 읽게 할 수 있음
- 자기 자신만의 데이터베이스 버전을 갖고 있다고 생각할 수 있음
  - 커밋할 때 갱신을 실제 데이터베이스에 적용
  - 데이터 읽기는 절대로 대기하는 일이 업음
- 너무 많은 스냅샷을 제공하는 것이 문제가 될 수 있음