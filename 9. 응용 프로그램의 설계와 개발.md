#### 9장

##응용 프로그램의 설계와 개발

- 사용자와 데이터베이스 사이의 대부분의 상호 작용은 응용 프로그램을 거쳐 간접적으로 이루어짐

### 응용 프로그램과 사용자 인터페이스

- 데이터베이스를 이용하는 가장 일반적인 방법은 앞단에서 사용자 인터페이스를 제공하고 뒷단에서 데이터베이스와 통신하는 응용 프로그램을 사용하는 것
  - 앞단 : 사용자 인터페이스 제공
  - 뒷단 : 데이터베이스과 통신
  - 앞단과 뒷단 사이에서는 비즈니스 로직 수행
- 사용자의 PC에 응용 프로그램을 설치할 필요가 겂음
  - 웹 브라우저는 인터넷을 통해 데이터베이스와 통신하는 일반적인 인터페이스 유지
    - 정보의 표현을 형식화하는 HTML이라는 표준화된 문법 사용
- 웹 기반의 응용 프로그램은 인터넷이 연결되어 있는 모든 컴퓨터로부터 접근이 가능함

### 웹의 기본

#### URL

- 웹을 통해 접근 가능한 모든 문서에 대해 고유하게 주어지는 이름
  - <code>http://<웹 서버가 가동 중인 기계의 이름>/<고유한 식별자>?<인자></code>
    - 웹 서버는 주어진 인자들을 가지고 프로그램을 실행

- 브라우저가 웹 서버로 데이터를 전송하는 방법
  - get : 값을 url에 추가
  - post : 매개변수 값을 HTTP 프로토콜을 통해 브라우저에서 웹 서버로 보냄

#### 웹 서버와 세션

- 웹 서버 : 서버 측에서 동작하는 프로그램, 웹 브라우저의 요청을 받아 결과를 웹 문서의 형태로 반환

  - HTTP 규약을 이용해서 서로 통신
  - 사용자가 넘겨준 인자들을 이용해 프로그램을 실행, 결과를 HTML으로 반환
  - 데이터베이스로부터 원하는 자료를 얻기 위해 JDBC 등의 표준 규약 이용

- 여러 계층의 서버를 사용하면 시스템의 오버헤드가 커짐

  - 응용 프로그램이 웹 서버에서 수행되는 2단계 구조를 사용

- 클라이언트와 서버 사이의 연결은 지속적으로 유지되지 않음 = connectionless

  - 일시적으로 연결 생성, 응답이 이루어지면 연결이 종료됨
    - 다음 요청이 발생하면 새 연결이 생성됨
  - 비지속 연결을 사용한 이유 : 동시에 처리할 수 있는 접속 수에 제한이 있음
    - 응답을 해주면 해당 연결을 다른 요청을 서비스하기 위해 사용됨

- 세션 정보 : 사용자에 대한 인증은 하나의 세션에서 한 번만 이루어짐

  - 다시 재인증을 하는 것은 좋지 않음
  - 추가적인 정보는 클라이언트 측에 저장, 요청이 발생할 때마다 해당 정보를 반환
    - 서버는 해당 정보를 이용해서 사용자를 구분
  - 쿠키의 형태로 클라이언트에 저장 : 식별 정보와 이름을 담을 짧은 텍스트로 이루어짐
    - 사용자 인증 후에 쿠키를 생성

  - 세션을 추적하기 위해 세션 식별자(sessionid) 를 쿠키에 담아 서버에 보냄
    - 쿠키 값이 서버에 저장된 세션 식별자와 같은 경우, 해당 요청이 현재 세션에 속한 것으로 확인
    - 아니면 해당 요청이 현재 세션에 속하지 않은 것으로 판단

###서블릿과 JSP

- Java의 Servlet은 응용 프로그램과 웹 서버가 통신하는 인터페이스를 정의
  - 서블릿 인터페이스를 구현한 Java 프로그램과 클래스를 서블릿이라고 부름
  - HTTP 요청을 받으면 서블릿 코드가 서버에서 실행, 동적으로 HTML 페이지를 생성해서 반환

#### 서블릿 세션

- 웹 브라우저와 서버 간의 상호 작용은 무상태 = stateless
  - 원하는 정보를 얻은 뒤 연결을 끊음
  - 서블릿에서는 세션 관련 정보를 저장하는 방법을 제시 : HttpServletRequest
    - getSession(false) : 요청을 보낸 웹 브라우저에 대응되는 HttpSession 객체가 반환됨
    - getSession(true) : 인증을 성공적으로 마치면 새로운 세션 객체를 얻음
    - setArribute("aaa", aa) : 세션 매개변수를 저장
    - getAttribue("aaa") : 세션 변수를 찾을 수 있음

#### 서블릿 생활 주기

1. 서버에서 해당 서블릿의 인스턴스가 존재하는지 조사
   - 존재하지 않는 경우, 서버는 해당 서블릿을 JVM에 로드하고 서블릿 클래스의 인스턴스를 생성
     - 서블릿 인스턴스를 초기화 : 처음 생성될 때 단 한번만 초기화됨
2. request, response 객체를 매개변수로 하여 service 메소드를 호출, doGet, doPost 호출
   - 새로운 스레드를 생성 : 여러 요청들이 병렬적으로 동시에 수행될 수 있기 때문
3. 필요 없은 세블릿은 destroy() 메소드 호출

#### 서블릿 지원

- Tomcat 서버 등
  - 기본적인 서블릿 지원 외에도 여러 가지 유용한 서비스를 제공
    - 응용 프로그램을 배포하거나 저장지시킬 수 있음
    - 서블릿 코드가 변경되면 코드를 다시 컴파일하고 읽어들임

#### 서버 측 스크립팅

- Java Server Pages(JSP) : 정적인 HTML과 동적으로 생성되는 HTML을 혼합할 수 있는 스크립트 언어
  - HTML에 Java 코드를 삽입
    - JSP 스크립트는 서블릿 코드로 변환된 후 컴파일
  - HTML코드와 구부하기 위해 <% ... %> 로 둘러쌈

#### 클라이언트 측 스크립팅

- 동적인 모습을 모여주기 위해 : 사용자와 좀 더 유연한 상호 작용을 하기 위해
  - 서버에서 모든 작업을 처리하는 것보다 커다란 속도의 향상
- Javascript를 가장 많이 사용
  - HTML 코드를 분석해서 DOM이라는 표준을 따르는 인메모리 트리를 구성
    - Javascript는 트리의 구조를 변경할 수 있음
- Ajax : 동적 웹 페이지를 만들기 위한 Javascript
  - 웹 서버와 비동기적으로 통신

#### 웹 서비스

- HTTP 프로토콜을 통한 함수의 호출을 통해서 요청이 전달, 응용 프로그램 서버에서 실행된 후에 그 결과를 함수를 호출한 프로그램에 전달

1. REST : 표준 HTTP 요청을 통해서 웹 서비스 함수가 호출됨
   - 결과를 생성해서 HTTP 요청의 결과로서 전달
2. JSON 방식

### 응용 프로그램 성능

#### 캐싱에 의한 오버헤드 감소

- 트랜잭션 간의 공통 요소를 활용하기 위해 많은 캐싱 기법들이 사용됨
- 연결 풀(connection pool) 
  - 열린 ODBC/JDBC 연결들의 풀(집합)을 만든다
  - 사용자의 요청에 대해서 새로운 연결을 열지 않고, 연결 풀로부터 연결을 받아서 반환함
    - 데이터베이스 시스템이 허용하는 최대 동시 연결 수를 넘지 않도록 
  - 집중적으로 연결을 사용할 때 문제 발생
    - 프로그래머들은 열린 연결들을 닫아야 할 책임이 있음
- 예전의 질의의 결과를 캐싱해서 재사용
  - 응용 프로그램의 소스 코드 안에서 명시적으로 수행
  - 저장된 페이지를 재사용함으로써 페이지 재생성 비용을 줄일 수 있음

#### 병렬 처리

- 많은 수의 응용 프로그램 서버를 병렬적으로 실행
- 데이터베이스가 공유되고 있기 때문에, 데이터베이스에서 병목 현상이 일어날 수 있음
  - 질의 결과를 캐싱
  - 데이터베이스의 요청의 수를 최소화

### 응용 프로그램 보안

#### SQL 삽입(SQL Injection)

- 공격자가 자신이 생성한 SQL 질의를 응용 프로그램이 수행하게 만드는 것
  - 임의의 SQL문을 삽입해서 응용 프로그램에 의해서 실행하는데 성공
    - 보안 수단을 회피해서 시스템에 심각한 피해를 줄 수 있음
- 준비된 질의문(prepared statement)을 사용
  - 매개변수를 설정할 때 JDBC는 자동으로 탈출 문자를 추가해서 매개 변수가 포함된 따옴표가 문자열을 끝내지 못하도록 함
  - 문자열을 SQL 질의에 포함시키기 전에 탈출 문자를 추가하는 함수를 적용해도 동일한 효과
- 응용 프로그램이 입력되는 값이 허가된 값들 중 하나인지 확인하는 과정 추가

####Cross Site 스크립팅(XSS)과 허위 요청

- 일반적인 문자열로 이루어진 이름이나 댓글을 입력하는 대신에, Javascript와 같은 클라이언트 측 스크립트 언어를 입력
  - 웹 브라우저는 해당 스크립트를 실행해서 개인적인 쿠키 정보를 악의적인 사용자에게 보내는 것과 같은 작업을 하거나, 사용자가 로그인하고 있는 다른 웹 서버에서 작업을 실행할 수 있음
- 방지하는 방법
  1. 웹사이트가 XSS나 XSRF 공격이 실행하는데 사용되지 않도록 해야 함
     - 입력하는 문자열에 HTML 태그를 입력하지 못하게 함
  2. 다른 웹사이트에서 실행되는 XSS나 XSRF 공격으로부터 웹사이트를 보호
     - 해당 페이지를 접근하는 referer를 확인할 수 있음
       - 페이지를 접근하기 위해서 사용자가 클릭한 페이지를 알 수 있음
       - 다른 웨사이트에서 온 것인지를 판단
     - 처음에 인증된 IP 주소로만 세션을 제한
     - 갱신을 할 때 get 요청을 사용하지 않음

#### 응용 프로그램 인증

- 인증은 데이터베이스에 접속하는 소프트웨어나 사람의 신원을 확인하는 작업
- 많은 프로그램은 2-factor 인증을 사용
  - 두 가지 독립된 요소를 사용, 두 요소는 공통된 취약점을 가져서는 안됨
  - 미닐번호, OTP(one-time password, 매번 새로운 임의의 숫자를 생성)
  - Man-in-the-middle 공격에 취약함
    - 두 번째 factor를 포함한 비밀번호를 얻어내기 위해 원래의 웹사이트가 아닌 가짜 웹사이트로 유도
      - 얻어낸 정보를 이용해서 원래 응용 프로그램의 인증을 얻음
    - HTTPS 프로토콜은 사용자가 가짜 웹사이트에 연결하지 않도록 웹사이트를 인증
- 단일 사용인증(single-sign-on)
  - 한 번 인증 절차를 거치기만 하면 별도의 재인증 없이도 여러 응용 프로그램이 중앙 인증 서비스를 통해 사용자의 신원을 확인하는 방법

#### 데이터베이스의 암호와 지원

- 파일에 대한 정보를 담고 있는 디렉토리와 대용량 파일이 주로 암호화의 대상

- 서로 다른 여러 단계에서 암호화가 가능함

  - 릴레이션의 특정 속성을 암호화된 형태로 저장할 수 있음

    - 각 속성마다 서로 다른 암호화 키를 가질 수 있음
    - 중요한 정보만 암호화 = 복호화의 부담을 최소화

    - 서로 다른 속성에 대한 복호화 키는 파일 또는 지갑(wallet)이라고 불리는 릴레이션의 형태로 저장
      - 지갑 역시 마스터 키를 사용해서 암호화

  - 데이터베이스 수준의 암호화 방식

    - 시간과 공간 오버헤드가 낮음
    - 응용 프로그램을 수정할 필요가 없음

- 마스터 키

  - 컴퓨터의 응용 프로그램에 저장
  - 데이터베이스 사용자가 암기

  