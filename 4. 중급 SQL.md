#### 4장

## 중급 SQL

### 조인

- 자연 조인(natural join) 

  - 조인 조건을 지정할 수 있음
    - 지정한 조건으로 자연 조인에 의해서 제거된 튜플을 결과에 포함시킬 수 있음

- <code>on</code> : 조인될 릴레이션에 대한 일반적인 조건을 정할 수 있음

  ~~~sql
  select * from A join B on A.a = B.a
  ~~~

  - 외부 조인과 같은 경우에는 on조건은 where 조건과 다르게 사용될 수 있음
  - 조인 조건은 on 절에 명시하고, 나머지 부분은 where 절에 나타내면 SQL 질의를 더 쉽게 해석할 수 있음

#### 외부 조인 (outer join)

- 조인의 결과에서 빠질 수 있는 튜플을 null값을 이용해서 보존함

1. 왼쪽 외부 조인(left outer join) : 왼쪽에 나타는 릴레이션의 튜플만을 보존함
2. 오른쪽 외부 조인(right outer join) : 오른쪽에 나타난 릴레이션의 튜플만을 보존함
3. 전체 외부 조인(full outer join) : 모든 튜플을 보존
   - 왼쪽 외부 조인과 오른쪽 외부 조인을 통합한 것

- 실행 과정 (왼쪽 외부 조인을 예시)

  1. 내부 조인의 결과를 수행
  2. 조인 연산의 왼쪽에 위치한 릴레이션에 존재하는 튜플 중에서 내부 조인에서 조인 연산의 오른쪽에 위치한 릴레이션의 튜플과 연결되지 않은 모든 튜플을 추가
  3. 왼쪽 연산의 속성은 그래도 채워짐
  4. 나머지 속성은 모두 null 로 채워진다

  - 오른쪽 외부 조인은 왼쪽 외부 조인과 대칭적임

- on과 where 은 외부 조인에서는 다르게 동작

  - 내부 조인에서 견결되지 못한 퓨틀에 대해서만 널 값을 이용해서 결과에 추가

- 일반적인 조인을 내부 조인(inner join) 이라고 부름
  - 자연 조인(natural join) = 자연 내부 조인(natural inner join)

#### 뷰(view)

- 모든 사용자가 전체 논리적인 모델을 보는 것은 바람직하지 않음
  - 보안상 특정 정보를 사용자에게 숨겨야 할 필요가 있음
- 질의어에 의해서 정의되는 가상 릴레이션을 제공
  - 질의의 결과를 개념적으로 포함
  - 가상 릴레이션이 사용될 때마다 질의를 수행해서 결과를 얻어냄

~~~sql
create view v as <query>;
~~~

- 데이터베이스 시스템이 뷰 릴레이션과 관련된 질의 식을 저장하고 있음
  - 뷰 릴레이션이 접근될 때마다 질의 결과를 계산함으로써 튜플이 생성됨
  - 뷰 릴레이션을 필요할 때마다 생성됨
  - 질의에서 뷰 릴레이션이 나타날 때마다 그 자리에 저장된 질의 식을 바꿔 넣음
    - 질의를 계산할 때마다 뷰 릴레이션이 다시 계산됨
- 실체화 뷰(materialized view)
  - 뷰 릴레이션을 저장하는 방법을 제공
  - 릴레이션이 수정되어도 뷰는 최신 상태를 유지함 = 실체화 뷰 관리(materialized view maintenance)
    - 수정이 일어날 때마다 즉시 수행
    - 뷰가 접근될 때 뷰 관리를 수행
    - 주기적으로 실체화 뷰를 수정 
  - 큰 릴레이션에 대해서 집계 연산을 수행하는데 빠른 응답을 요구하는 경우 등
  - 실체화 뷰로부터 얻는 이득이 추가적인 갱신과 저장하는데 쓰이는 비용보다 커야함

- 갱신, 삽입 및 삭제 등의 연산을 뷰를 사용하여 표현할 때 많은 문제점 존재
  - 뷰에 대한 수정은 그 데이터베이스의 논리적 모델 내의 실제 릴레이션들에 대한 수정으로 변환해야 함
  - 삽입 문제
    1. 삽입을 거부하고 사용자에게 오류 메세지 출력
    2. 값이 없으면 null로 삽입
  - 일부 경우를 제외하고 일반적으로 뷰 릴레이션에 대한 변경을 허용되지 않음
  - 갱신가능(updatable)
    - From 절은 오직 하나의 릴레이션을 가져야 함
    - Select 절은 릴레이션의 속성 이름만 포함, 표현, 집계, 구분이 없어야 함
    - Select 절에 나열되지 않은 어떤 속성오 null값이 될 수 있어야 함 = not null이나 주키의 일부가 아니어야 함
    - group by나 having 절을 가지면 안된다
    - 이러한 조건들을 만족하는 뷰는 update, insert, delete 연산이 가능함
  - <code>with check option</code> 절에 의해 갱신의 조건을 정의할 수 있음

#### 트랜젝션 (transaction)

- 일련의 질의와 갱신문으로 이루어져 있음
  - sql문이 시작되는 순간에 암묵적으로 트랜젝션이 시작된다고 명시

1. commit work : 트랜젝션에 의해 수행된 갱신들을 영구적으로 반영
   - commit을 하면 rollback에 의해 더 이상 취소될 수 잆엄
2. rollback work : 수행된 모든 갱신을 모두 취소(undo) 함
   - 첫 구문이 실행되기 전의 상태로 돌아감
   - 데이터베이스는 트랜젝션이 원자적(atomic) 이라는 성질을 보장할 수 있음
   - 모두 반영하거나 롤백에 의해 아무런 효과를 주지 않아야 함

- 이 두 명령 중 하나도 실행하지 않고 끝나는 프로그램이 있다면, 갱신은 커밋이나 롤백 둘 주 ㅇ하나가 됨

  - 자동 커밋을 트랜젝연시 여러개의 SQL문으로 구성되는 경에는 해제 되어야 함

    ~~~sql
    begin atomic ... end
    ~~~

  - 키워드 사이에 있는 모든 구문은 단일 트랜젝션을 형성함

#### 무결정 제약조건 (integrity constraint)

- 데이터베이스 변경이 데이터 일관성(data consistency)에 손실을 초래하지 않음을 보장
- 최소의 계산 처리 비용으로 검증될 수 있는 무결성 제약조건들 만을 지원함
- <code>create table</code> 명령어의 일부분으로 정의할 수 있음
  - <code>alter table A add CONSTRAINT</code> 명령어를 이용해서 이미 존재하는 릴레이션에 추가 가능
- 조건을 만족하지 않는다면 그 명령어는 거절됨

- 단일 릴레이션에서의 제약조건

  1. not null

     - null 값을 도메인의 값이 될 수 없음
     - 릴레이션 스키마의 주 키에 대해서 널 값을 막는 것은 필수적임

  2. unique

     - <code>unique(A1, A2, ..., Am)</code>
       - A1, ..., Am이 후보 키를 구성한다는 것을 나타냄
       - 후보 키 속성은 명시적으로 not null 이라고 선언하지 않는 한 널 값을 가질 수 있음

  3. check 절

     - <code>check(P)</code> : 릴레이션의 모든 튜플에 의해 만족되는 술어 P를 명시

     - 속성값이 명시된 조건들을 만족하는 것을 보장

       ~~~sql
       create table A (...., check(a in ('a', 'b', 'c')));
       ~~~

- 참조 무결성(referential integrity) : 다른 릴레이션에 대한 속성 집합의 값으로 반드시 나타나야 하는 경우

  - <code>foreign key</code> 절을 사용한 create table 명령어
  - 참조 무결성 제약조건(referential-integrity constraints) : t1.K1 = t2.a 라고 하면, 관계 r2의 속성 집합 R2의 부분 집합 a를 r1릴레이션의 주 키 K1을 참조하는 외래 키라고 정의

  - 기본적으로 외래 키는 참조되는 테이블의 주 키 속성을 참조함
    - 속성에 대한 리스트를 명백하게 기술할 수 있는 변형된 <code>references</code> 절을 제공
    - 주 키 제약조건을 사용하거니 unique조건을 사용해서 반드시 참조되는 릴레이션의 루보 키로 선언되어야 함
  - 참조 무결성 제약조건이 위반되었을 때 기본적인 절차는 위반을 유발시킨 동작을 거부함
    - foreign key 절은 참조되는 릴레이션에서 삭제나 갱신 동작이 제약조건 위반을 발생시키면 그 동작을 거부하는 대신, 참조하는 릴레이션의 튜플을 변환하는 절차는 저장
    - <code>on delete cascade</code> : 참조하는 튜플을 연쇄적으로 삭제함
    - Cascade 자리에 set null을 사용해서 기본 값을 지정(set default) 할 수 있음
    - 외래키의 속성들은 not null 로 선언되지 않았다면 null값이 되도록 허용함
  - 무결설 제약조건을 트랜젝션의 중간 단계가 아닌 트랜젝션의 마지막 단계에서 검사되어야 하는 경우
    - 연기가능(deferrable)하게 명시될 수 있음 : 기본적으로 즉시 검사를 하지만, 원하는 다른 시간으로 연기할 수 있음
    - <code>set constraints [제약 조건 목록] deferred</code> 명령어로 명시된 제약조건 검사를 트랜젝션의 마지막 단계로 연산
      - Deferred의 표시가 없으면 즉시 제약도건을 검사함

- check 조건 : 데이터의 무결성을 보장하고 싶지만 확인해야 하는 작업의 비용이 클 때 유용하게 사용

  - 주장(assertion)은 데이터베이스가 항상 만족시키길 원하는 조건을 표현하는 술어

    ~~~sql
    create assertion [name] check [predicate];
    ~~~

#### 데이터 타입과 스키마

- 날짜와 시간 타입

  1. date : 년도(yyyy), 월, 일
  2. time : 시간, 시, 분, 초, 시간과 시간대(time with timezone)
  3. timestamp : date + time의 조합, 시간대 정보 또한 저장됨

  - <code>cast e as t</code> : 문자열 e를 타입 t로 변환할 수 있음
    - t는 date, time, timestamp 중 하나가 됨
    - e는 제대로된 형태를 가지고 있어야 함
  - <code>extract(FIELD from d)</code> : field의 year, month, dat, hout, minute, second 등을 추출
    - Current_date : 현재의 날짜, current_time : 현재의 시간, localtime : 현재의 지역 시간
    - 비교 연산 : <code>interval</code> 을 사용해서 시간 간격을 계산할 수 있음

- 기본값 : <code>create table</code> 문에서 속성에 대한 특정 기본 값을 명시할 수 있음

  ~~~sql
  create table A (
  	... ,
  	a numeric(3, 0) default 0,
  	...
  );
  ~~~

- 인덱스 생성 (index) : 모든 튜플을 살펴보는 과정 없이 효과적으로 원하는 튜플을 찾을 수 있는 자료구조

  - 가장 많이 사용되고 있는 인덱스의 종류인 B+트리

  ~~~sql
  create index INDEX_NAME on TABLE_NAME(COLUMN_NAME);
  ~~~

- 대형 객체 타임

  - 초대용량의 속성들을 저장해야 하는 경우
  - 문자데이터(clob), 이지데이터(blob)
  - 대형 객체를 한번에 메모리로 가져오는 것은 빟율적임 = SQL 질의로 대형 객체에 위치안 위치자(locator)를 얻어서 사용

- 사용자 정의 타입

  - distinct type, structured data type(중첩 레코드 타입, 배열, 다중 집합으로 된 복잡한 데이터 타입)
  - <code>create type</code> 절로 새로운 도메인을 정의할 수 있음

- <code>create table</code> 의 확장

  - <code>create table A like B</code> : 현재 존재하는 테이블과 같은 스키마를 가지고 있는 테이블 생성
  - <code>create table A as (select ....) with data;</code> : 질의의 결과를 임시로 새로운 테이블로 저장
    - with data가 없는 경우 테이블은 생성되지만 데이터가 입력되지 않음

#### 스키마, 카탈로그, 환경

- 릴레이션 명명에서 3단계의 계층을 제공
  - 카탈로그(catalog) -> 스키마(schema) -> 릴레이션, 뷰(SQL 객체)
- 데이터베이스에서 어떤 동작을 수행하기 위해서는 데이터베이스에 먼저 접속해야 함
  - 각 사용자는 기본 카탈로그와 스키마를 보유
  - 릴레이션을 유일하게 구분하기 위해서는 세 부분의 이름을 모두 사용해야 함
    - <code>catalog.schema.relation</code>
- 카탈로그와 스키마는 각 접속에 대해 설정되는 SQL 환경(SQL environment)의 일부
  - 환경에는 부가적으로 사용자 식벽자(권한 식별자)

#### 권한 (privilage)

- 권한을 사용자에게 할당할 수 있음

  1. 데이터 읽기

  2. 데이터 삽입

  3. 데이터 갱신

  4. 데이터 삭제

- 전부 혹은 전혀 할당하지 않거나 조합해서 일부부만 할당할 수 있음

- 사용자가 가지고 있는 권한을 기반으로 질의가 갱신이 허가된 것인지 먼저 확인, 허가되지 않으면 거부

- 다른 사용자에게 부여하거나 이전에 부여받은 권한을 취소할 수 있음

- 권한 부여와 취소

  - <code>all privileges</code> : 허용되는 모든 권한의 축약 형태로 사용됨

    - 새로운 릴레이션을 생성하는 사용자는 그 릴레이션에 대한 모든 권한을 자동적으로 받게됨

  - <code>grant</code> : 권한을 수여하는데 사용

    ~~~sql
    grant [privilege list] on [relation] to [user/role];
    ~~~

    - Privilege list

      1. select : 튜플을 읽는데 필요한 권한
      2. update : 튜플을 수정할 수 있는 권한
         - 모든 속성에 부여되거나 일부 속성에 부여될 수 있음
         - 부여할 속성의 목록을 괄호 안에 명시 : <code>update(a, b, c)</code>

      3. insert : 튜플을 삽입하는 권한
         - 속성의 목록을 기술할 수 있고, 나머지 속성들에 기본값(없으면 null)로 지정
      4. delete : 튜플을 삭제하는 권한

    - public 이라는 사용자 이름은 현재와 앞으로 사용할 모든 사용자를 지정함

  - 권한을 부여받은 사용자/역할은 다른 사용자/역할에 권한을 부여할 수 없음

    - 권한을 전달하려 하는 것을 명시할 수 있음

  - 특정 튜플에 대한 권한을 주는 것은 허용하지 않음

  - <code>revoke</code> : 권한을 취소

#### 뷰의 권한

- 질의 처리기가 질의를 데이터베이스의 실제 릴레이션을 위해 변환했을 때, 질의 처리를 시작하기 전에 해당 사용자가 권한을 가지고 있는지 확인해야 함
- 뷰를 생성하는 사용자가 해당 뷰에 대한 모든 권한을 가질 필요는 없음

#### 권한의 전달

- <code>with grant option</code> : 권한을 다른 사용자에게 넘겨줄 수 있음

  ~~~sql
  grant select on A to B with grant option;
  ~~~

- 객체(릴레이션, 뷰, 역할)의 생성자는 권한을 넘겨줄 수 있는 것을 포함한 그 객체에 대한 권한을 가지게 됨

- 권한 그래프(authorization graph) 로 표현

- 권한의 취소

  - 어떤 사용자/역할의 권한이 취소되면 다른 사용자/역할도 그 권한이 취소될 수 있음

    - 연쇄 취소(sacading revocation)

  - 연쇄 취소를 방지하기 위해서 restrict 를 사용

    ~~~sql
    revoke select on A from B, C restrict;
    ~~~

    - 연쇄 취소가 일어나는 경우 오류를 출력하고 취소 작업을 수행하지 않음
    - 취소가 연쇄적으로 일어나야하는 경우 cascade 사용 : 기본적으로 수행, 생략 가능